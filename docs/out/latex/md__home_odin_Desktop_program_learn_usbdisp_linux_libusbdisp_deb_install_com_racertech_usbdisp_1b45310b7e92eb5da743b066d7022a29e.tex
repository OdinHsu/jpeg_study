\hypertarget{md__home_odin_Desktop_program_learn_usbdisp_linux_libusbdisp_deb_install_com_racertech_usbdisp_1b45310b7e92eb5da743b066d7022a29e_autotoc_md44}{}\doxysection{Quick Start}\label{md__home_odin_Desktop_program_learn_usbdisp_linux_libusbdisp_deb_install_com_racertech_usbdisp_1b45310b7e92eb5da743b066d7022a29e_autotoc_md44}
This section explains how to write a basic client for EVDI. Details of API calls are omitted here for brevity.\hypertarget{md__home_odin_Desktop_program_learn_usbdisp_linux_libusbdisp_deb_install_com_racertech_usbdisp_1b45310b7e92eb5da743b066d7022a29e_autotoc_md45}{}\doxysection{Typical application}\label{md__home_odin_Desktop_program_learn_usbdisp_linux_libusbdisp_deb_install_com_racertech_usbdisp_1b45310b7e92eb5da743b066d7022a29e_autotoc_md45}
Applications using EVDI will typically\+:


\begin{DoxyItemize}
\item find a free EVDI node, or add a new node if none was found; then open it
\item connect to the EVDI node, letting the DRM subsystem know what is the monitor that the application drives
\item allocate memory for, and register buffer(s) that will be used to receive screen updates
\item request and consume updates and other notifications in a loop whenever the kernel \href{details.md\#evdi_selectable}{\texttt{ signals updates are ready}}
\end{DoxyItemize}\hypertarget{md__home_odin_Desktop_program_learn_usbdisp_linux_libusbdisp_deb_install_com_racertech_usbdisp_1b45310b7e92eb5da743b066d7022a29e_autotoc_md46}{}\doxysubsection{EVDI nodes}\label{md__home_odin_Desktop_program_learn_usbdisp_linux_libusbdisp_deb_install_com_racertech_usbdisp_1b45310b7e92eb5da743b066d7022a29e_autotoc_md46}
EVDI reuses DRM subsystem\textquotesingle{}s {\ttfamily cardX} nodes for passing messages between the kernel and userspace. In order to distinguish non-\/\+EVDI nodes from a node that\textquotesingle{}s created by EVDI kernel module, {\ttfamily evdi\+\_\+check\+\_\+device} function should be used.

The library only allows to connect to DRM nodes that are created by EVDI. Attempts to connect to other nodes (e.\+g. related to a built-\/in GPU) will fail.\hypertarget{md__home_odin_Desktop_program_learn_usbdisp_linux_libusbdisp_deb_install_com_racertech_usbdisp_1b45310b7e92eb5da743b066d7022a29e_autotoc_md47}{}\doxysubsubsection{Adding new nodes (pre v1.\+9.\+0)}\label{md__home_odin_Desktop_program_learn_usbdisp_linux_libusbdisp_deb_install_com_racertech_usbdisp_1b45310b7e92eb5da743b066d7022a29e_autotoc_md47}
!!! note Requires administrative rights. To call this your application needs to have been run with {\ttfamily sudo}, or by root.

In order to create a new EVDI {\ttfamily cardX} node, call {\ttfamily evdi\+\_\+add\+\_\+device} function. A single call adds one additional DRM card node that can later be used to connect to.

At the moment, every extra screen that you want to manage needs a separate node.\hypertarget{md__home_odin_Desktop_program_learn_usbdisp_linux_libusbdisp_deb_install_com_racertech_usbdisp_1b45310b7e92eb5da743b066d7022a29e_autotoc_md48}{}\doxysubsubsection{Opening EVDI node (pre v1.\+9.\+0)}\label{md__home_odin_Desktop_program_learn_usbdisp_linux_libusbdisp_deb_install_com_racertech_usbdisp_1b45310b7e92eb5da743b066d7022a29e_autotoc_md48}
Once an available EVDI node is identified, your application should call {\ttfamily evdi\+\_\+open}, passing a number of {\ttfamily cardX} that you want to open. This returns an {\ttfamily evdi\+\_\+handle} that you will use for following API calls, or {\ttfamily EVDI\+\_\+\+INVALID\+\_\+\+HANDLE} if opening failed.\hypertarget{md__home_odin_Desktop_program_learn_usbdisp_linux_libusbdisp_deb_install_com_racertech_usbdisp_1b45310b7e92eb5da743b066d7022a29e_autotoc_md49}{}\doxysubsubsection{Requesting EVDI node (since v1.\+9.\+0)}\label{md__home_odin_Desktop_program_learn_usbdisp_linux_libusbdisp_deb_install_com_racertech_usbdisp_1b45310b7e92eb5da743b066d7022a29e_autotoc_md49}
!!! note Requires administrative rights. To call this your application needs to have been run with {\ttfamily sudo}, or by root.

Adding and opening evdi devices is easier since libevdi v1.\+9.\+0. It\textquotesingle{}s sufficient to call {\ttfamily evdi\+\_\+open\+\_\+attached\+\_\+to(\+NULL)} in order to add a new evdi node and open it.

It is possible to bind evdi devices with usb devices if it is necessary to show such relationship in sysfs. It is done via {\ttfamily const char $\ast$sysfs\+\_\+parent\+\_\+device} parameter of {\ttfamily evdi\+\_\+open\+\_\+attached\+\_\+to} function. USB parent device is described by a string with the following format\+: {\ttfamily usb\+:\mbox{[}bus\+Num\mbox{]}-\/\mbox{[}port\+Num1\mbox{]}.\mbox{[}port\+Num2\mbox{]}.\mbox{[}port\+Num3\mbox{]}...}

e.\+g. A {\ttfamily evdi\+\_\+open\+\_\+attached\+\_\+to(\char`\"{}usb\+:2-\/2.\+1\char`\"{})} call will link {\ttfamily /sys/bus/usb/devices/2-\/2.1/evdi.\+0} to {\ttfamily /sys/bus/platform/devices/evdi.0} which is the first available evdi node.

If an available device exists calling this does not require administrative rights. Otherwise, administrative rights are needed to create a new device. You can ensure a device is available by \href{details.md\#module-parameters}{\texttt{ configuring the kernel module}} to create devices when it is loaded.\hypertarget{md__home_odin_Desktop_program_learn_usbdisp_linux_libusbdisp_deb_install_com_racertech_usbdisp_1b45310b7e92eb5da743b066d7022a29e_autotoc_md50}{}\doxysubsubsection{Closing EVDI node}\label{md__home_odin_Desktop_program_learn_usbdisp_linux_libusbdisp_deb_install_com_racertech_usbdisp_1b45310b7e92eb5da743b066d7022a29e_autotoc_md50}
In order to close the handle, call {\ttfamily evdi\+\_\+close}.\hypertarget{md__home_odin_Desktop_program_learn_usbdisp_linux_libusbdisp_deb_install_com_racertech_usbdisp_1b45310b7e92eb5da743b066d7022a29e_autotoc_md51}{}\doxysubsubsection{Removing EVDI nodes}\label{md__home_odin_Desktop_program_learn_usbdisp_linux_libusbdisp_deb_install_com_racertech_usbdisp_1b45310b7e92eb5da743b066d7022a29e_autotoc_md51}
!!! note Requires administrative rights. To write to this file your application needs to have been run with {\ttfamily sudo}, or by root.

Write to {\ttfamily /sys/devices/evdi/remove\+\_\+all}. For example\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{echo 1 | sudo tee /sys/devices/evdi/remove\_all}

\end{DoxyCode}
\hypertarget{md__home_odin_Desktop_program_learn_usbdisp_linux_libusbdisp_deb_install_com_racertech_usbdisp_1b45310b7e92eb5da743b066d7022a29e_autotoc_md52}{}\doxysubsection{Connecting and disconnecting}\label{md__home_odin_Desktop_program_learn_usbdisp_linux_libusbdisp_deb_install_com_racertech_usbdisp_1b45310b7e92eb5da743b066d7022a29e_autotoc_md52}
Connecting to EVDI tells DRM subsystem that there is a monitor connected, and from this moment the system is aware of an extra display. Connection also lets DRM know what is the \href{https://en.wikipedia.org/wiki/Extended_Display_Identification_Data}{\texttt{ EDID}} of the monitor that a particular EVDI node handles. Think of this as something similar to plugging a monitor with a cable to a port of a graphics card.

Similarly, disconnecting indicates that the display is no longer there -\/ like physically pulling cable out from the graphics adapter port.

To connect or disconnect, use {\ttfamily evdi\+\_\+connect} and {\ttfamily evdi\+\_\+disconnect}, respectively.\hypertarget{md__home_odin_Desktop_program_learn_usbdisp_linux_libusbdisp_deb_install_com_racertech_usbdisp_1b45310b7e92eb5da743b066d7022a29e_autotoc_md53}{}\doxysubsection{Frame buffers}\label{md__home_odin_Desktop_program_learn_usbdisp_linux_libusbdisp_deb_install_com_racertech_usbdisp_1b45310b7e92eb5da743b066d7022a29e_autotoc_md53}
To know what the contents of the screen is, your application will use a block of memory that it can read pixel data from.

The library itself does {\itshape not} allocate any memory for buffers -\/ this is to allow more control in the client application. Therefore, before you request screen updates for the screens you\textquotesingle{}re managing, an appropriate amount of memory must be allocated to hold screen data within your application. The application can register as many buffers as you like, and subsequent update requests can refer to any buffer that was previously registered.

Allocated memory is made available for EVDI library to use by calling {\ttfamily evdi\+\_\+register\+\_\+buffer}. Symmetrically, {\ttfamily evdi\+\_\+unregister\+\_\+buffer} is used to tell the library not to use the buffer anymore.\hypertarget{md__home_odin_Desktop_program_learn_usbdisp_linux_libusbdisp_deb_install_com_racertech_usbdisp_1b45310b7e92eb5da743b066d7022a29e_autotoc_md54}{}\doxysubsection{Cursor}\label{md__home_odin_Desktop_program_learn_usbdisp_linux_libusbdisp_deb_install_com_racertech_usbdisp_1b45310b7e92eb5da743b066d7022a29e_autotoc_md54}
Mouse cursor is an important part of the desktop. Because of this, evdi provides special control over it.

There are two ways to handle cursor\+:


\begin{DoxyItemize}
\item Automatic cursor compositing on framebuffer(default). Every cursor change causes {\ttfamily update\+\_\+ready} event to be raised. In the following grab pixels operation evdi will compose cursor on the user supplied framebuffer.
\item Cursor change notifications. Controlled with {\ttfamily evdi\+\_\+enable\+\_\+cursor\+\_\+events} function call. In that mode the responsibility for cursor blending is passed to the library client. Instead of {\ttfamily update\+\_\+ready} event the {\ttfamily cursor\+\_\+set} and {\ttfamily cursor\+\_\+move} notifications are sent.
\end{DoxyItemize}\hypertarget{md__home_odin_Desktop_program_learn_usbdisp_linux_libusbdisp_deb_install_com_racertech_usbdisp_1b45310b7e92eb5da743b066d7022a29e_autotoc_md55}{}\doxysubsection{DDC/\+CI}\label{md__home_odin_Desktop_program_learn_usbdisp_linux_libusbdisp_deb_install_com_racertech_usbdisp_1b45310b7e92eb5da743b066d7022a29e_autotoc_md55}
As part of creating an EVDI node, the module also creates an i2c adapter. This can be used to pass DDC/\+CI buffers to and from the connected monitor to adjust brightness and contrast. Data requests to this adapter for DDC/\+CI (on address 0x37) are passed to userspace as DDC/\+CI data notifications via {\ttfamily ddcci\+\_\+data\+\_\+handler} and responses are passed back using {\ttfamily evdi\+\_\+ddcci\+\_\+response}.\hypertarget{md__home_odin_Desktop_program_learn_usbdisp_linux_libusbdisp_deb_install_com_racertech_usbdisp_1b45310b7e92eb5da743b066d7022a29e_autotoc_md56}{}\doxysubsection{Running loop}\label{md__home_odin_Desktop_program_learn_usbdisp_linux_libusbdisp_deb_install_com_racertech_usbdisp_1b45310b7e92eb5da743b066d7022a29e_autotoc_md56}
You are expected to promptly handle events and to \href{details.md\#requesting-an-update}{\texttt{ request updates}} and \href{details.md\#grabbing-pixels}{\texttt{ grab pixels}} regularly for any virtual monitor you have connected. If you fail to do so the device may become unresponsive.\hypertarget{md__home_odin_Desktop_program_learn_usbdisp_linux_libusbdisp_deb_install_com_racertech_usbdisp_1b45310b7e92eb5da743b066d7022a29e_autotoc_md57}{}\doxysubsection{Events and notifications}\label{md__home_odin_Desktop_program_learn_usbdisp_linux_libusbdisp_deb_install_com_racertech_usbdisp_1b45310b7e92eb5da743b066d7022a29e_autotoc_md57}
Due to its design and split of responsibilities between the kernel and userspace code, EVDI\textquotesingle{}s working model is an asynchronous one. Therefore, your application should monitor a file descriptor exposed by {\ttfamily evdi\+\_\+get\+\_\+event\+\_\+ready} function, and whenever it becomes ready to read, call {\ttfamily evdi\+\_\+handle\+\_\+events} to dispatch events that are being signalled to the right handlers.

The handlers are defined in your application and are shared with the library through a {\ttfamily \mbox{\hyperlink{structevdi__event__context}{evdi\+\_\+event\+\_\+context}}} structure that {\ttfamily evdi\+\_\+handle\+\_\+events} uses for dispatching the call.\hypertarget{md__home_odin_Desktop_program_learn_usbdisp_linux_libusbdisp_deb_install_com_racertech_usbdisp_1b45310b7e92eb5da743b066d7022a29e_autotoc_md58}{}\doxysubsubsection{Types of events}\label{md__home_odin_Desktop_program_learn_usbdisp_linux_libusbdisp_deb_install_com_racertech_usbdisp_1b45310b7e92eb5da743b066d7022a29e_autotoc_md58}
The notifications your application can (and should) be handling, are\+:


\begin{DoxyItemize}
\item Update ready notification (sent once a request to update a buffer is handled by kernel)
\item Mode changed notification (sent from DRM after screen mode is changed)
\item DPMS notifications (telling the new power state of a connector)
\item CRTC state change event (exposing DRM CRTC state)
\item Cursor events (send when cursor position or state changes)
\item DDC/\+CI notification (sent when an i2c request for DDC/\+CI data is made)
\end{DoxyItemize}

You will start receiving first notifications from the kernel module right after connecting to EVDI. Your application should use this information before you ask for screen updates to make sure the buffers are the right size.\hypertarget{md__home_odin_Desktop_program_learn_usbdisp_linux_libusbdisp_deb_install_com_racertech_usbdisp_1b45310b7e92eb5da743b066d7022a29e_autotoc_md59}{}\doxysubsection{Logging}\label{md__home_odin_Desktop_program_learn_usbdisp_linux_libusbdisp_deb_install_com_racertech_usbdisp_1b45310b7e92eb5da743b066d7022a29e_autotoc_md59}
By default libevdi uses {\ttfamily printf} to print messages to stdout. Client application can provide its own callback which will be used instead by calling {\ttfamily evdi\+\_\+set\+\_\+logging}. The same function can be used to switch back to default behaviour (by setting callback to {\ttfamily NULL}); 